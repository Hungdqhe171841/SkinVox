const express = require('express');
const router = express.Router();
const aiService = require('../services/aiService');

// Knowledge base for beauty and makeup questions
const knowledgeBase = {
  // Skincare questions
  'da d·∫ßu': {
    keywords: ['da d·∫ßu', 'da nh·ªùn', 'd·∫ßu', 'nh·ªùn', 'oily'],
    response: `ƒê·ªëi v·ªõi da d·∫ßu, b·∫°n n√™n:
1. **L√†m s·∫°ch**: S·ª≠ d·ª•ng s·ªØa r·ª≠a m·∫∑t cho da d·∫ßu 2 l·∫ßn/ng√†y (s√°ng v√† t·ªëi)
2. **Toner**: D√πng toner kh√¥ng c·ªìn ƒë·ªÉ c√¢n b·∫±ng pH
3. **Serum**: Niacinamide ho·∫∑c Salicylic Acid gi√∫p ki·ªÉm so√°t d·∫ßu
4. **Kem d∆∞·ª°ng**: Ch·ªçn gel ho·∫∑c lotion nh·∫π, kh√¥ng g√¢y b√≠t t·∫Øc
5. **Kem ch·ªëng n·∫Øng**: B·∫Øt bu·ªôc! Ch·ªçn lo·∫°i kh√¥ng d·∫ßu (oil-free)
6. **Makeup**: S·ª≠ d·ª•ng primer ki·ªÉm so√°t d·∫ßu v√† setting spray

**S·∫£n ph·∫©m g·ª£i √Ω**: Foundation d·∫°ng l·ªèng, powder compact, blotting papers ƒë·ªÉ ki·ªÉm so√°t d·∫ßu trong ng√†y.`
  },
  
  'chƒÉm s√≥c da': {
    keywords: ['chƒÉm s√≥c da', 'skincare', 'routine', 'quy tr√¨nh'],
    response: `**Quy tr√¨nh chƒÉm s√≥c da c∆° b·∫£n h√†ng ng√†y:**

üåÖ **BU·ªîI S√ÅNG:**
1. R·ª≠a m·∫∑t v·ªõi s·ªØa r·ª≠a m·∫∑t nh·∫π
2. Toner
3. Serum Vitamin C (t√πy ch·ªçn)
4. Kem d∆∞·ª°ng ·∫©m
5. **Kem ch·ªëng n·∫Øng** (quan tr·ªçng nh·∫•t!)

üåô **BU·ªîI T·ªêI:**
1. T·∫©y trang (n·∫øu c√≥ makeup)
2. R·ª≠a m·∫∑t
3. Toner
4. Serum ƒëi·ªÅu tr·ªã (Retinol, AHA/BHA t√πy nhu c·∫ßu)
5. Kem d∆∞·ª°ng ·∫©m

**M·∫πo**: U·ªëng ƒë·ªß n∆∞·ªõc, ng·ªß ƒë·ªß gi·∫•c, v√† thay ƒë·ªïi khƒÉn g·ªëi th∆∞·ªùng xuy√™n!`
  },
  
  'm√†u son': {
    keywords: ['m√†u son', 'son m√¥i', 'lipstick', 'ch·ªçn son', 'm√†u son ph√π h·ª£p'],
    response: `**C√°ch ch·ªçn m√†u son ph√π h·ª£p:**

üé® **Theo t√¥ng da:**
- **Da tr·∫Øng**: H·∫ßu h·∫øt m√†u ƒë·ªÅu ƒë·∫πp, th·ª≠ c√°c t√¥ng nude, h·ªìng, ƒë·ªè t∆∞∆°i
- **Da ngƒÉm**: T√¥ng ƒë·ªè ƒë·∫≠m, cam, berry, nude ·∫•m
- **Da v√†ng**: Cam san h√¥, ƒë·ªè cam, nude ·∫•m, h·ªìng ƒë√†o

üí° **Theo khu√¥n mi·ªáng:**
- **M√¥i m·ªèng**: Son b√≥ng ho·∫∑c m√†u s√°ng ƒë·ªÉ t·∫°o ƒë·ªô ƒë·∫ßy
- **M√¥i d√†y**: C√≥ th·ªÉ d√πng m·ªçi m√†u, son matte r·∫•t ƒë·∫πp

**G·ª£i √Ω**: Th·ª≠ nghi·ªám v·ªõi AR Makeup c·ªßa SkinVox ƒë·ªÉ xem m√†u son ph√π h·ª£p tr∆∞·ªõc khi mua!`
  },
  
  'che khuy·∫øt ƒëi·ªÉm': {
    keywords: ['che khuy·∫øt ƒëi·ªÉm', 'concealer', 'che', 'm·ª•n', 'th√¢m'],
    response: `**C√°ch che khuy·∫øt ƒëi·ªÉm hi·ªáu qu·∫£:**

1. **Ch·ªçn ƒë√∫ng m√†u**: Concealer n√™n s√°ng h∆°n foundation 1-2 t√¥ng
2. **K·ªπ thu·∫≠t**: D√πng c·ªç ho·∫∑c beauty blender, tap nh·∫π, kh√¥ng k√©o
3. **M√†u ƒëi·ªÅu ch·ªânh**:
   - ƒê·ªè/m·ª•n ƒë·ªè ‚Üí M√†u xanh l√° c√¢y
   - Th√¢m qu·∫ßng m·∫Øt ‚Üí M√†u cam/peach
   - Da v√†ng/kh√¥ng ƒë·ªÅu ‚Üí M√†u t√≠m/lavender

4. **B∆∞·ªõc th·ª±c hi·ªán**:
   - Thoa m·ªôt ch·∫•m nh·ªè l√™n khuy·∫øt ƒëi·ªÉm
   - D√πng ng√≥n tay ho·∫∑c c·ªç nh·ªè tap ƒë·ªÅu
   - Set v·ªõi powder ƒë·ªÉ l√¢u tr√¥i
   - Blend v·ªõi foundation xung quanh

**M·∫πo**: D√πng primer tr∆∞·ªõc ƒë·ªÉ concealer b√°m t·ªët h∆°n!`
  },
  
  'foundation': {
    keywords: ['foundation', 'kem n·ªÅn', 'ph·∫•n n·ªÅn', 'base makeup'],
    response: `**H∆∞·ªõng d·∫´n ch·ªçn v√† d√πng foundation:**

üéØ **Ch·ªçn lo·∫°i:**
- **Da kh√¥**: Liquid foundation, dewy finish
- **Da d·∫ßu**: Matte foundation, powder foundation
- **Da h·ªón h·ª£p**: Satin finish, buildable coverage

üé® **Ch·ªçn m√†u:**
- Test tr√™n v√πng quai h√†m, kh√¥ng ph·∫£i tay
- M√†u ph√π h·ª£p khi blend v√†o da t·ª± nhi√™n
- Ki·ªÉm tra d∆∞·ªõi √°nh s√°ng t·ª± nhi√™n

üí´ **C√°ch apply:**
1. D∆∞·ª°ng ·∫©m v√† primer tr∆∞·ªõc
2. D√πng beauty sponge ho·∫∑c brush
3. Apply t·ª´ gi·ªØa ra ngo√†i
4. Set v·ªõi powder ·ªü v√πng T-zone

**SkinVox AR** gi√∫p b·∫°n th·ª≠ m√†u foundation ·∫£o tr∆∞·ªõc khi mua!`
  },
  
  'eyeshadow': {
    keywords: ['eyeshadow', 'ph·∫•n m·∫Øt', 'trang ƒëi·ªÉm m·∫Øt'],
    response: `**H∆∞·ªõng d·∫´n trang ƒëi·ªÉm m·∫Øt:**

üëÅÔ∏è **K·ªπ thu·∫≠t c∆° b·∫£n:**
1. **Base**: D√πng primer m·∫Øt ho·∫∑c concealer ƒë·ªÉ m√†u b√°m v√† l√¢u tr√¥i
2. **M√†u n·ªÅn**: M√†u s√°ng nh·∫•t cho to√†n b·ªô m√≠
3. **M√†u t·∫°o chi·ªÅu s√¢u**: M√†u ƒë·∫≠m h∆°n ·ªü g√≥c ngo√†i v√† n·∫øp g·∫•p m·∫Øt
4. **Highlight**: M√†u s√°ng nh·∫•t ·ªü x∆∞∆°ng ch√¢n m√†y v√† g√≥c trong m·∫Øt
5. **Blend**: Quan tr·ªçng! Blend ƒë·ªÉ kh√¥ng c√≥ ƒë∆∞·ªùng ranh gi·ªõi r√µ r√†ng

üé® **M√†u c∆° b·∫£n c·∫ßn c√≥:**
- M√†u nude/beige
- M√†u n√¢u ƒë·∫≠m
- M√†u highlight
- M√†u t·ª± ch·ªçn theo s·ªü th√≠ch

**SkinVox AR** c√≥ b·ªô Eyeshadow Presets ƒë·ªÉ b·∫°n th·ª≠ nghi·ªám!`
  },
  
  'blush': {
    keywords: ['blush', 'm√° h·ªìng', 'rouge', 'm√° ph·∫•n'],
    response: `**C√°ch ƒë√°nh m√° h·ªìng t·ª± nhi√™n:**

üå∏ **V·ªã tr√≠ ƒë√∫ng:**
- C∆∞·ªùi nh·∫π ƒë·ªÉ x√°c ƒë·ªãnh ph·∫ßn m√° n·ªïi cao
- ƒê√°nh t·ª´ gi·ªØa m√° ra ngo√†i, l√™n tr√™n m·ªôt ch√∫t v·ªÅ ph√≠a th√°i d∆∞∆°ng
- Kh√¥ng ƒë√°nh qu√° g·∫ßn m≈©i

üé® **M√†u s·∫Øc:**
- **Da tr·∫Øng**: H·ªìng ph·∫•n, h·ªìng ƒë√†o
- **Da v√†ng**: Cam san h√¥, ƒë√†o ·∫•m
- **Da ngƒÉm**: ƒê·ªè cam, berry ƒë·∫≠m

üí´ **K·ªπ thu·∫≠t:**
- D√πng brush l·ªõn, l√¥ng m·ªÅm
- Tap nh·∫π, blend ra ngo√†i
- Build t·ª´ nh·∫π ƒë·∫øn ƒë·∫≠m

**SkinVox AR** c√≥ Blush Presets ƒë·ªÉ b·∫°n th·ª≠ m√†u tr∆∞·ªõc!`
  }
};

// Default responses for greetings and common questions
const defaultResponses = {
  greetings: [
    'Xin ch√†o! T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n v·ªÅ l√†m ƒë·∫πp?',
    'Ch√†o b·∫°n! B·∫°n mu·ªën bi·∫øt g√¨ v·ªÅ makeup hay skincare?',
    'Hi! T√¥i s·∫µn s√†ng t∆∞ v·∫•n v·ªÅ l√†m ƒë·∫πp cho b·∫°n!'
  ],
  general: [
    'T√¥i hi·ªÉu b·∫°n ƒëang quan t√¢m ƒë·∫øn ch·ªß ƒë·ªÅ n√†y. B·∫°n c√≥ th·ªÉ h·ªèi c·ª• th·ªÉ h∆°n kh√¥ng? V√≠ d·ª•: "S·∫£n ph·∫©m n√†o ph√π h·ª£p v·ªõi da d·∫ßu?" ho·∫∑c "C√°ch ch·ªçn m√†u son?"',
    'ƒê·ªÉ t√¥i t∆∞ v·∫•n t·ªët h∆°n, b·∫°n c√≥ th·ªÉ h·ªèi v·ªÅ: skincare routine, ch·ªçn s·∫£n ph·∫©m makeup, k·ªπ thu·∫≠t trang ƒëi·ªÉm, ho·∫∑c chƒÉm s√≥c da. B·∫°n mu·ªën bi·∫øt g√¨ c·ª• th·ªÉ?'
  ]
};

// Function to find relevant response
function findResponse(message) {
  const lowerMessage = message.toLowerCase();
  
  // Check for greetings
  if (lowerMessage.match(/ch√†o|hello|hi|xin ch√†o|hey/)) {
    return defaultResponses.greetings[
      Math.floor(Math.random() * defaultResponses.greetings.length)
    ];
  }
  
  // Check knowledge base
  for (const [key, data] of Object.entries(knowledgeBase)) {
    const found = data.keywords.some(keyword => lowerMessage.includes(keyword));
    if (found) {
      return data.response;
    }
  }
  
  // Check for specific product questions
  if (lowerMessage.includes('s·∫£n ph·∫©m') || lowerMessage.includes('product')) {
    return `SkinVox c√≥ nhi·ªÅu s·∫£n ph·∫©m makeup ch·∫•t l∆∞·ª£ng:
- **Lipstick**: Nhi·ªÅu m√†u s·∫Øc, texture m·ªãn m√†ng
- **Eyeshadow**: B·∫£ng m√†u ƒëa d·∫°ng, pigment cao
- **Blush**: T·ª± nhi√™n, d·ªÖ blend
- **Foundation**: Nhi·ªÅu t√¥ng m√†u, ph√π h·ª£p m·ªçi lo·∫°i da

B·∫°n c√≥ th·ªÉ xem v√† th·ª≠ s·∫£n ph·∫©m qua AR Makeup t·∫°i BeautyBar. B·∫°n quan t√¢m lo·∫°i s·∫£n ph·∫©m n√†o?`;
  }
  
  // Check for AR/Makeup AR questions
  if (lowerMessage.includes('ar') || lowerMessage.includes('th·ª≠') || lowerMessage.includes('makeup ar')) {
    return `**SkinVox AR Makeup** l√† c√¥ng ngh·ªá th·ª≠ trang ƒëi·ªÉm ·∫£o:
‚ú® Th·ª≠ son m√¥i, eyeshadow, blush, eyebrow, eyeliner tr·ª±c ti·∫øp tr√™n khu√¥n m·∫∑t
üì± S·ª≠ d·ª•ng camera ƒë·ªÉ xem hi·ªáu ·ª©ng real-time
üé® H√†ng trƒÉm m√†u s·∫Øc v√† preset ƒë·ªÉ l·ª±a ch·ªçn

C√°ch d√πng:
1. V√†o trang **BeautyBar** ho·∫∑c **Makeup AR**
2. Ch·ªçn s·∫£n ph·∫©m mu·ªën th·ª≠
3. Cho ph√©p truy c·∫≠p camera
4. Xem v√† ch·ªçn m√†u ph√π h·ª£p v·ªõi b·∫°n!

B·∫°n mu·ªën th·ª≠ s·∫£n ph·∫©m n√†o?`;
  }
  
  // Check for blog/content questions
  if (lowerMessage.includes('blog') || lowerMessage.includes('b√†i vi·∫øt') || lowerMessage.includes('m·∫πo')) {
    return `SkinVox c√≥ nhi·ªÅu b√†i vi·∫øt h·ªØu √≠ch v·ªÅ:
üìù M·∫πo l√†m ƒë·∫πp
üíÑ H∆∞·ªõng d·∫´n trang ƒëi·ªÉm
üå∏ ChƒÉm s√≥c da
üî• Xu h∆∞·ªõng l√†m ƒë·∫πp m·ªõi nh·∫•t

B·∫°n c√≥ th·ªÉ xem t·∫°i m·ª•c **Blog** tr√™n website. B·∫°n quan t√¢m ch·ªß ƒë·ªÅ g√¨?`;
  }
  
  // Default response
  return defaultResponses.general[
    Math.floor(Math.random() * defaultResponses.general.length)
  ] + ` 

T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªÅ:
- üíÑ Ch·ªçn s·∫£n ph·∫©m makeup ph√π h·ª£p
- üå∏ ChƒÉm s√≥c da h√†ng ng√†y
- üé® K·ªπ thu·∫≠t trang ƒëi·ªÉm
- üì± C√°ch s·ª≠ d·ª•ng AR Makeup
- üí° M·∫πo l√†m ƒë·∫πp

B·∫°n mu·ªën bi·∫øt g√¨ c·ª• th·ªÉ?`;
}

// @route   POST /api/chatbot/message
// @desc    Handle chatbot message and return response using AI (Gemini/OpenAI) with fallback
// @access  Public
router.post('/message', async (req, res) => {
  try {
    const { message, conversationHistory = [] } = req.body;
    
    if (!message || !message.trim()) {
      return res.status(400).json({
        success: false,
        message: 'Vui l√≤ng nh·∫≠p c√¢u h·ªèi'
      });
    }
    
    let response = null;
    let provider = 'fallback';
    
    // Try AI first if available
    if (aiService.isAvailable()) {
      try {
        console.log('ü§ñ Chatbot: Attempting to use AI...');
        const aiResult = await aiService.getAIResponse(message, conversationHistory);
        if (aiResult) {
          response = aiResult.response;
          provider = aiResult.provider;
          console.log(`‚úÖ Chatbot: Successfully using ${provider} AI`);
        } else {
          console.log('‚ö†Ô∏è  Chatbot: AI service returned null, using fallback');
        }
      } catch (error) {
        console.error('‚ùå Chatbot: AI Service error:', error.message);
        console.log('üìö Chatbot: Falling back to knowledge base');
        // Fall through to knowledge base
      }
    } else {
      console.log('üìö Chatbot: AI not available, using knowledge base');
    }
    
    // Fallback to knowledge base if AI fails or not available
    if (!response) {
      response = findResponse(message);
    }
    
    res.json({
      success: true,
      response: response,
      provider: provider,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('‚ùå Chatbot Debug - Error:', error);
    res.status(500).json({
      success: false,
      message: 'ƒê√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   GET /api/chatbot/health
// @desc    Check chatbot service health and AI availability
// @access  Public
router.get('/health', async (req, res) => {
  const aiAvailable = aiService.isAvailable();
  const providers = aiService.getAvailableProviders();
  
  // Test Gemini connection if available
  let geminiTest = null;
  if (aiAvailable && providers.includes('Gemini')) {
    try {
      const testResult = await aiService.getAIResponse('test', []);
      geminiTest = {
        status: 'connected',
        provider: testResult.provider
      };
    } catch (error) {
      geminiTest = {
        status: 'error',
        error: error.message.substring(0, 100)
      };
    }
  }
  
  res.json({
    success: true,
    message: 'Chatbot service is running',
    aiAvailable: aiAvailable,
    aiProviders: providers,
    geminiTest: geminiTest,
    timestamp: new Date().toISOString(),
    note: aiAvailable ? 'AI is configured and ready' : 'AI not configured - using knowledge base fallback'
  });
});

module.exports = router;
